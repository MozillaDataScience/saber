---
title: '`r rjson::fromJSON(file="../report.json")$title`'
author: '`r rjson::fromJSON(file="../report.json")$author` <<`r rjson::fromJSON(file="../report.json")$email`>>'
Status: '<*final*>'
date: '`r rjson::fromJSON(file="../report.json")$publish_date`'
output:
  html_document:
    theme: cosmo
    toc: true
    toc_float: true
---
```{r global_options, include=FALSE, echo=FALSE, paged.print=TRUE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path='images/',
                      echo=FALSE, warning=FALSE, message=FALSE)
```

```{r setup}
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  p <- sapply(pkg, require, character.only = TRUE)
}
ipak(c("plotly", "tidyverse", "DT", "htmltools"))
```

```{r}
report <- rjson::fromJSON(file="../report.json")
experiment <- rjson::fromJSON(file="../experiment.json")
```

Status: <*final*>

## Supporting Assets
- [Experimenter](https://experimenter.services.mozilla.com/experiments/separate-search-default-in-private-browsing/)

# Motivation
The Search team wants to understand how many users would choose to enable a separate search engine for private browsing mode and if this would impact our search volume.

# Design
<p align="center"><img src=../design.png width=400px alt='experiment_mockup'></p>
<!-- ![](images/design.png) -->


# {.tabset}

## Executive Summary 

### Objective
The goal of the experiment is to see if there was any impact to search volume with enable the ability to choose a separate search engine for private browsing mode. Also, we would like to understand what percentage of users would enable a separate search engine for private browsing.

### Discussion
From this study, here are some of our general conclusions:

- We saw that there was no reliable impact on the search volume.

- There were virtually no switches to a separate private browser engine on the treatment branches.

## Methods
### Terminology

For this study, we used the following terms for our analysis:

Our study has three branches, `control`, `treatment-no-banner`, `treatment-banner`:
- `control` refers to our cohort of users who did not receive any changes to their Firefox experience.
- `treatment-no-banner` refers to our cohort of users who had the option in Preferences to enable a separate search engine for private browsing mode but there was no intervention to let them know.
- `treatment-banner` refers to our cohort of users who received a doorhanger to inform them that they can enable a separate search engine for private browsing mode.

### Data Assets
This experiment launched on `r experiment$start_date`, and targeted 0.2% of Firefox Release Users (smaller sample to mitigate any potential revenue impact) on version 71 to 73. These users were randomly sampled and assigned one of the three experimental conditions: `control`, `treatment-no-banner`, or `treatment-banner`.

We evaluated six measures of interactions in this study on a `per user` basis:

1. *Organic* search weekly volume count

2. *sap* search weekly volume count

3. Number of enabled separate search engines for private browsing mode

## Tables

```{r echo=FALSE}
metrics <- list()
for (table_name in experiment$metrics) {
  for (metric in names(table_name)) {
    metrics[metric] <- table_name[[metric]]
  }
}

df <- read_csv(paste0('../data/', experiment["last_date_full_data"],'_', report['experiment_slug'], '.csv'))
```

```{r}
create_summary_list <- function(df, alpha_level=.01) {
  ci <- c((alpha_level/2), (1-(alpha_level/2)))
  ci_cols <- sapply(ci, toString)

  rel_uplift <- df %>% filter(analysis == 'rel_uplift')
  rel_uplift['sig'] = sign(rel_uplift[ci_cols[1]] * rel_uplift[ci_cols[2]])
  branches <- pull(unique(rel_uplift['branch']))
  
  # figure out why there are nans in the results
  rel_uplift[is.na(rel_uplift)] = 0
  
  # create ci column
  ci_bound <- as.character((1 - alpha_level) * 100)
  rel_uplift$ci <- paste0(ci_bound, "% CI [ ",
                          round(pull(rel_uplift, ci_cols[1]), 4)*100,
                          "%, ",
                          round(pull(rel_uplift, ci_cols[2]), 4)*100, "% ]")
  rel_uplift$expected_mean <- paste0(round(pull(rel_uplift, exp), 4)*100, "%")
  
  rel_uplift <- rel_uplift %>%  select(metric, expected_mean, ci, sig, branch)
  
  metric_descriptions = c()
  for (metric in rel_uplift$metric) {
    metric_descriptions = c(metric_descriptions, metrics[[metric]])
  }
  # give a more detailed metric description
  rel_uplift <- rel_uplift %>% mutate(metric = metric_descriptions)
  
  summary_list <- split(rel_uplift, f=rel_uplift$branch)
  
  return(summary_list)
}
```

```{r}
create_table <- function(summary)  {   
  # since summary is split by branch, this could be any element from the column
  branch_name <- first(summary$branch)
  datatable(summary,
            colnames= c('Metric of Interest' = 'metric',
                        'Percentage Change' = 'expected_mean', 
                        'Confidence Interval' = 'ci',
                        'Significance' = 'sig'),
            caption=paste0("Overall Percentage Changes for Each Each Metric\n(`",
                           branch_name, "` - `control`)"),
            options=list(
                      dom='t',
                      columnDefs=list(
                        list(className='dt-left', targets=2),
                        list(visible=F, targets=c(4,5))
                      )
                    )
) %>%
  # formatPercentage("expected_mean", 2) %>%
  formatStyle(
    "Significance",
    color = styleEqual(c(-1, 0, 1), c("grey", "blue", "blue")),
    fontWeight = styleEqual(c(-1, 1), c("regular", "bold"))
  ) %>%
  formatStyle(c(1),
              fontWeight = "bold"
              ) %>% return()
}
```

```{r, fig.height=4.5, fig.width=5}
summary_list <- create_summary_list(df)
tagList(lapply(summary_list, create_table))
```

```{r}
totals <- read_csv('../data/spbm_totals.csv')
datatable(totals, colnames=c('Branch Name'='branch',
                             'Number of Users per Branch'='n_users',
                             'Total SAP searches'='total_sap',
                             'Total Organic searches'='total_organic',
                             'Total Separate PBM switches'='total_switch'
                             ),
          options=list(dom='t'),
          caption='Overall Totals per Branch')
```


```{r}
# (ggplot(df %>% filter(metric == "sap")) + geom_boxplot(mapping=aes(x=branch, y=exp))) %>% ggplotly()
```

